<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Мат королевой — детализированная линейная 2D-аниме анимация</title>
<meta name="color-scheme" content="dark">
<style>
/* =========================
   GLOBAL / LAYOUT
   ========================= */
:root{
  --bg:#000000;
  --board-size: min(84vmin,900px);
  --light:#f0d9b5;
  --dark:#6b4b33;
  --white-line: #ffffff;
  --accent: rgba(255,215,140,0.95);
}
*{box-sizing:border-box}
html,body{height:100%; margin:0; background:var(--bg); color:var(--white-line); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
.container{
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:22px;
  gap:28px;
}
/* frame holds board and scene overlay */
.frame{
  width:var(--board-size);
  max-width:95vw;
  border-radius:12px;
  overflow:hidden;
  position:relative;
  box-shadow: 0 30px 80px rgba(0,0,0,0.75), inset 0 1px 0 rgba(255,255,255,0.02);
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
}

/* small UI: Reset only (hidden thin) */
.reset {
  position:absolute;
  right:12px; top:12px;
  z-index:200;
  background:transparent;
  border:1px solid rgba(255,255,255,0.06);
  color:var(--white-line);
  padding:6px 10px;
  border-radius:8px;
  font-size:13px;
  cursor:pointer;
  backdrop-filter: blur(4px);
}

/* =========================
   CHESSBOARD (PROPORTIONAL)
   ========================= */
.board {
  width:100%;
  display:grid;
  grid-template-columns: repeat(8,1fr);
  border-radius:10px;
  overflow:hidden;
  user-select:none;
  -webkit-user-select:none;
  position:relative;
}

/* squares keep perfect aspect ratio via aspect-ratio (modern browsers) */
.square{
  aspect-ratio: 1/1;
  display:flex;
  align-items:center;
  justify-content:center;
  transition: background 180ms ease, transform 120ms ease;
  position:relative;
  cursor:pointer;
}
.square.light{ background: var(--light); }
.square.dark{ background: var(--dark); color:#0b0906; }
.square.highlight{ box-shadow: inset 0 0 0 8px rgba(255,230,170,0.14); }
.square.invalid{ animation: shake 380ms linear; }
@keyframes shake { 0%{ transform:translateX(0) } 25%{ transform:translateX(-6px)} 50%{ transform:translateX(6px)} 75%{ transform:translateX(-4px)} 100%{ transform:translateX(0)} }

.piece-svg{
  width:78%;
  height:78%;
  display:block;
  pointer-events:none;
  filter: drop-shadow(0 18px 30px rgba(0,0,0,0.55));
  transition: transform 160ms ease;
}

/* small dot showing selectable piece */
.select-dot{
  position:absolute;
  right:8px; bottom:8px;
  width:12px; height:12px; border-radius:50%;
  background:var(--accent);
  box-shadow:0 6px 16px rgba(255,180,80,0.08);
  opacity:0;
  transform:scale(0.8);
  transition:opacity 160ms, transform 160ms;
}
.square.selectable .select-dot{ opacity:1; transform:scale(1); }

/* message overlay (subtle) */
.msg{
  position:absolute;
  left:12px; bottom:12px;
  background: rgba(0,0,0,0.45);
  border:1px solid rgba(255,255,255,0.03);
  color: #e8f6ff;
  padding:8px 12px;
  border-radius:10px;
  font-size:13px;
  z-index:140;
}

/* =========================
   SCENE — full black canvas (line-art)
   ========================= */
.scene {
  position:absolute;
  left:0; top:0; right:0; bottom:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: #000;
  z-index:150;
  visibility:hidden;
  opacity:0;
  transition:opacity 420ms ease, visibility 1ms linear 420ms;
  pointer-events:none;
}
.scene.visible { visibility:visible; opacity:1; pointer-events:auto; transition-delay:0ms; }

/* stylized caption (hidden) */
.scene .helper{
  position:absolute; left:14px; top:14px; color:rgba(255,255,255,0.06); font-size:12px; z-index:210;
}

/* =========================
   SVG animation specifics
   - We'll animate stroke-dasharray for drawing
   - Use CSS classes to control keyframes
   ========================= */

/* Generic draw animation (line-by-line) */
.line-draw {
  stroke: var(--white-line);
  stroke-width:2.6;
  stroke-linecap:round;
  stroke-linejoin:round;
  fill:none;
  stroke-dasharray: 1200;
  stroke-dashoffset: 1200;
  animation: drawLine 900ms ease forwards;
}
@keyframes drawLine {
  to { stroke-dashoffset: 0; }
}

/* Slightly faster for details */
.line-draw-fast {
  stroke: var(--white-line);
  stroke-width:2.2;
  stroke-linecap:round;
  stroke-linejoin:round;
  fill:none;
  stroke-dasharray: 900;
  stroke-dashoffset: 900;
  animation: drawLineFast 560ms ease forwards;
}
@keyframes drawLineFast {
  to { stroke-dashoffset: 0; }
}

/* pulse effect on impact */
@keyframes impactPulse {
  0% { transform: scale(0.6); opacity:1; }
  70% { transform: scale(1.06); opacity:0.9; }
  100% { transform: scale(1.3); opacity:0; }
}

/* camera shake wrapper */
.camera-shake { transform-origin: center; }

/* speed lines (appear / fade) */
.speedlines { opacity:0; transform: translateX(-20px); transition:opacity 220ms ease, transform 260ms ease; }
.speedlines.show { opacity:1; transform: translateX(0); }

/* sword trail (glow) */
.sword-trail { stroke:#fff; stroke-opacity:0.9; stroke-width:3.2; filter: drop-shadow(0 6px 14px rgba(255,255,255,0.04)); }

/* crown flying */
.crown { stroke:#fff; stroke-width:2.6; fill:none; transform-origin: center; }

/* king fall */
.king-line { stroke:#fff; stroke-width:2.8; fill:none; }

/* subtle vignette */
.vignette {
  pointer-events:none;
  position:absolute; inset:0; z-index:201;
  background: radial-gradient(60% 60% at 30% 30%, rgba(0,0,0,0) 0%, rgba(0,0,0,0.28) 45%, rgba(0,0,0,0.6) 100%);
}

/* small responsive tweak */
@media (max-width:520px){
  .msg{ font-size:12px; padding:6px 8px; left:8px; bottom:8px; }
  .reset{ right:8px; top:8px; padding:5px 8px; font-size:12px; }
}
</style>
</head>
<body>
<div class="container">
  <div class="frame" id="frame">
    <button class="reset" id="resetBtn" title="Reset position">Reset</button>

    <div id="board" class="board" aria-label="Шахматная доска" role="application"></div>
    <div class="msg" id="msg">Выбери белую ♕ (h6), затем кликни на g7 чтобы поставить мат.</div>

    <div id="scene" class="scene" aria-hidden="true">
      <div class="vignette"></div>
      <!-- Helper (very subtle; invisible normally) -->
      <div class="helper" aria-hidden="true"></div>

      <!-- Complex SVG animation (line-art, white on black) -->
      <svg id="sceneSvg" viewBox="0 0 1280 720" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="softBlur" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="2.2" result="b" />
            <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
          </filter>
        </defs>

        <rect width="100%" height="100%" fill="#000" />

        <!-- Speedlines group (background) -->
        <g id="speedlines" class="speedlines" stroke="#fff" stroke-opacity="0.06" stroke-width="6" stroke-linecap="round">
          <path d="M60 0 L420 720" />
          <path d="M140 0 L500 720" stroke-width="8" />
          <path d="M220 0 L580 720" />
          <path d="M300 0 L660 720" stroke-width="5" />
          <path d="M380 0 L740 720" />
        </g>

        <!-- Camera wrapper to apply shake -->
        <g id="camera" class="camera-shake">

          <!-- QUEEN (left) — composed of multiple strokes for good drawing animation -->
          <g id="queenGroup" transform="translate(300,360)">
            <!-- cloak / body silhouette -->
            <path id="qBody" class="line-draw" d="M-44 52 C-28 -42, 28 -42, 44 52 L44 94 L-44 94 Z" stroke-width="3.2" />
            <!-- head -->
            <circle id="qHead" class="line-draw-fast" cx="0" cy="-62" r="16" stroke-width="2.8" />
            <!-- hair / details -->
            <path id="qHair" class="line-draw-fast" d="M-12 -70 C-6 -86, 6 -86, 12 -70" stroke-width="2.2" />
            <!-- face hint -->
            <path id="qFace" class="line-draw-fast" d="M-6 -58 Q0 -52 6 -58" stroke-width="1.8" />
            <!-- cloak flowing lines -->
            <path id="qCloak1" class="line-draw-fast" d="M-34 36 C-12 -6, 12 -6, 34 36" stroke-width="2.2" />
            <path id="qCloak2" class="line-draw-fast" d="M-28 66 Q0 40 28 66" stroke-width="2.0" />

            <!-- sword (will animate across) -->
            <g id="qSword" transform="translate(62,-26) rotate(-36)">
              <rect id="sBlade" x="-8" y="-6" width="240" height="12" rx="6" fill="#fff" opacity="0" />
              <rect id="sHandle" x="232" y="-4" width="48" height="8" rx="4" fill="#fff" opacity="0" />
              <!-- trailing stroke for line-art feel (invisible at first) -->
              <path id="sTrail" class="sword-trail" d="M-4 0 L240 -20" stroke-linecap="round" stroke-opacity="0.0" />
            </g>
          </g>

          <!-- KING (right) -->
          <g id="kingGroup" transform="translate(880,320)">
            <path id="kBody" class="king-line" d="M-28 -80 H28 V24 Q14 52 -14 52 H-14 Q-28 52 -28 24 Z" stroke-width="3.2" />
            <circle id="kHead" class="king-line" cx="0" cy="-100" r="14" stroke-width="2.8" />
            <!-- crown is a series of small paths (we will fly a copy) -->
            <path id="kCrown" d="M-22 -126 L-12 -138 L0 -126 L12 -138 L22 -126" stroke="#fff" stroke-width="2.6" fill="none" />
          </g>

          <!-- Impact flare circle (appears at target) -->
          <g id="impactGroup" opacity="0">
            <circle id="impactCircle" cx="720" cy="300" r="0" fill="#fff" opacity="0.08" />
          </g>

          <!-- crown flying copy (separate element for animation) -->
          <g id="crownFly" opacity="0">
            <path d="M-22 -126 L-12 -138 L0 -126 L12 -138 L22 -126" stroke="#fff" stroke-width="2.6" fill="none" transform="translate(880,194)" />
          </g>

        </g> <!-- camera -->

        <!-- foreground accents: quick particles, lines -->
        <g id="foreground" opacity="1">
          <g id="flash" opacity="0">
            <path d="M640 220 L700 280" stroke="#fff" stroke-width="2.8" stroke-linecap="round" />
            <path d="M700 260 L740 300" stroke="#fff" stroke-width="2.2" stroke-linecap="round" />
          </g>
        </g>

      </svg>
    </div> <!-- scene -->

  </div> <!-- frame -->
</div>

<script>
/* ===================================================================
   Full implementation:
   - Render a correct chessboard with classic pieces (SVG)
   - Allow selecting white queen at h6 and clicking g7
   - On correct move: animate queen move on board, fade board, then run scene
   - Scene timeline orchestrated robustly with timeouts / promises
   - All animations are CSS/SVG based and designed to run across browsers
   =================================================================== */

/* ---------- Board model ---------- */
const files = ['a','b','c','d','e','f','g','h'];
const ranks = [8,7,6,5,4,3,2,1];
const boardEl = document.getElementById('board');
const msg = document.getElementById('msg');
const resetBtn = document.getElementById('resetBtn');
const sceneRoot = document.getElementById('scene');
const sceneSvg = document.getElementById('sceneSvg');

let pieces = {
  'g6': {side:'w', type:'king'},
  'h6': {side:'w', type:'queen'},
  'g8': {side:'b', type:'king'},
  'g7': {side:'b', type:'pawn'},
};

const source = 'h6';
const target = 'g7';
let state = { selecting:false, selected:null };

function buildBoard(){
  boardEl.innerHTML = '';
  for(let r=0;r<8;r++){
    for(let f=0;f<8;f++){
      const sq = files[f] + ranks[r];
      const div = document.createElement('div');
      div.className = 'square ' + (((f + r) % 2 === 0) ? 'light' : 'dark');
      div.dataset.sq = sq;
      div.addEventListener('click', onSquareClick);
      if(pieces[sq]){
        const wrapper = document.createElement('div');
        wrapper.innerHTML = pieceSVG(pieces[sq].side, pieces[sq].type);
        const svg = wrapper.firstElementChild;
        svg.classList.add('piece-svg');
        if(sq === source && pieces[sq].type === 'queen') {
          // mark as selectable
          div.classList.add('selectable');
          const dot = document.createElement('div');
          dot.className = 'select-dot';
          div.appendChild(dot);
          svg.style.cursor = 'pointer';
          svg.addEventListener('click', (e) => { e.stopPropagation(); selectSource(sq); });
        }
        div.appendChild(svg);
      }
      boardEl.appendChild(div);
    }
  }
  msg.textContent = 'Выбери белую ♕ (h6), затем кликни на g7 чтобы поставить мат.';
}

function pieceSVG(side, type){
  // simplified classic stylized Staunton-like shapes using SVG paths
  if(type === 'king'){
    if(side === 'w'){
      return `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
        <g transform="translate(10,8)" fill="#ffffff" stroke="#0b0b0b" stroke-width="1.6">
          <rect x="52" y="6" width="6" height="18" rx="1.2" fill="#ffffff"/>
          <circle cx="56" cy="30" r="9" fill="#ffffff"/>
          <path d="M18 48 C36 18, 76 18, 98 48 L92 78 L24 78 Z" fill="#ffffff"/>
          <rect x="26" y="78" width="62" height="10" rx="4" fill="#ffffff"/>
        </g></svg>`;
    } else {
      return `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
        <g transform="translate(10,8)" fill="#111827" stroke="#03101a" stroke-width="1.6">
          <rect x="52" y="6" width="6" height="18" rx="1.2" />
          <circle cx="56" cy="30" r="9" />
          <path d="M18 48 C36 18, 76 18, 98 48 L92 78 L24 78 Z" />
          <rect x="26" y="78" width="62" height="10" rx="4" />
        </g></svg>`;
    }
  }
  if(type === 'queen'){
    if(side === 'w'){
      return `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
        <g transform="translate(8,6)" fill="#ffffff" stroke="#0b0b0b" stroke-width="1.4">
          <path d="M16 56 C36 18, 84 18, 104 56 L92 86 L28 86 Z" fill="#fff"/>
          <circle cx="26" cy="28" r="5" fill="#fff"/>
          <circle cx="56" cy="18" r="6" fill="#fff"/>
          <circle cx="86" cy="28" r="5" fill="#fff"/>
          <rect x="30" y="86" width="52" height="10" rx="4" fill="#fff"/>
        </g></svg>`;
    } else {
      return `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
        <g transform="translate(8,6)" fill="#111827" stroke="#03101a" stroke-width="1.4">
          <path d="M16 56 C36 18, 84 18, 104 56 L92 86 L28 86 Z" />
          <circle cx="26" cy="28" r="5" />
          <circle cx="56" cy="18" r="6" />
          <circle cx="86" cy="28" r="5" />
          <rect x="30" y="86" width="52" height="10" rx="4" />
        </g></svg>`;
    }
  }
  if(type === 'pawn'){
    if(side === 'w'){
      return `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
        <g transform="translate(12,12)" fill="#ffffff" stroke="#0b0b0b" stroke-width="1.2">
          <circle cx="36" cy="22" r="9" />
          <rect x="18" y="40" width="36" height="16" rx="4" />
        </g></svg>`;
    } else {
      return `<svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
        <g transform="translate(12,12)" fill="#111827" stroke="#03101a" stroke-width="1.2">
          <circle cx="36" cy="22" r="9" />
          <rect x="18" y="40" width="36" height="16" rx="4" />
        </g></svg>`;
    }
  }
  return '';
}

/* -------- Selection and move logic -------- */
function selectSource(sq){
  if(state.selecting) return;
  state.selecting = true;
  state.selected = sq;
  document.querySelectorAll('.square').forEach(s => s.classList.remove('highlight'));
  const srcEl = document.querySelector(`[data-sq="${sq}"]`);
  const tgtEl = document.querySelector(`[data-sq="${target}"]`);
  if(srcEl) srcEl.classList.add('highlight');
  if(tgtEl) tgtEl.classList.add('highlight');
  msg.textContent = 'Королева выбрана. Кликни на g7 чтобы поставить мат.';
}

function onSquareClick(e){
  const sq = e.currentTarget.dataset.sq;
  if(!state.selecting){
    // encourage selecting source
    e.currentTarget.classList.add('invalid');
    setTimeout(()=> e.currentTarget.classList.remove('invalid'),360);
    return;
  }
  if(state.selected !== source){
    state.selecting = false;
    state.selected = null;
    return;
  }
  if(sq === target){
    // correct move: animate queen, update model, then run scene
    msg.textContent = 'Ход корректен — мат. Запуск анимации...';
    animatePieceMove(source, target).then(()=> {
      // update pieces logically
      delete pieces[source];
      delete pieces[target]; // captured pawn
      pieces[target] = {side:'w', type:'queen'};
      // fade board and show scene
      fadeBoardThenScene();
    });
  } else {
    e.currentTarget.classList.add('invalid');
    setTimeout(()=> e.currentTarget.classList.remove('invalid'),360);
    msg.textContent = 'Это не тот ход. Кликни по g7.';
  }
}

/* animate piece movement by cloning SVG and moving absolute over board container */
function animatePieceMove(from, to){
  return new Promise((resolve) => {
    const fromEl = document.querySelector(`[data-sq="${from}"]`);
    const toEl = document.querySelector(`[data-sq="${to}"]`);
    if(!fromEl || !toEl){ resolve(); return; }

    const pieceSvg = fromEl.querySelector('.piece-svg');
    if(!pieceSvg){ resolve(); return; }

    // create clone as absolute positioned element
    const clone = pieceSvg.cloneNode(true);
    const boardRect = boardEl.getBoundingClientRect();
    const fRect = fromEl.getBoundingClientRect();
    clone.style.position = 'absolute';
    clone.style.left = (fRect.left - boardRect.left) + 'px';
    clone.style.top  = (fRect.top  - boardRect.top) + 'px';
    clone.style.width = fRect.width + 'px';
    clone.style.height = fRect.height + 'px';
    clone.style.zIndex = 120;
    clone.style.transition = 'all 520ms cubic-bezier(.2,.95,.2,1)';
    boardEl.appendChild(clone);

    // remove original
    const orig = fromEl.querySelector('.piece-svg');
    if(orig) orig.parentElement.remove();

    // target position
    const tRect = toEl.getBoundingClientRect();
    requestAnimationFrame(()=> {
      clone.style.left = (tRect.left - boardRect.left) + 'px';
      clone.style.top  = (tRect.top  - boardRect.top) + 'px';
      clone.style.transform = 'scale(1.02)';
    });

    setTimeout(()=> {
      clone.remove();
      resolve();
    }, 560);
  });
}

/* Fade board and start scene */
function fadeBoardThenScene(){
  // fade board to black and then show scene
  const frame = document.getElementById('frame');
  // hide squares quickly (fade)
  boardEl.style.transition = 'opacity 420ms ease';
  boardEl.style.opacity = 0;
  document.getElementById('msg').style.opacity = 0;
  setTimeout(()=> {
    boardEl.style.display = 'none';
    document.getElementById('msg').style.display = 'none';
    startScene();
  }, 440);
}

/* Reset button */
resetBtn.addEventListener('click', ()=>{
  // restore board DOM and model
  pieces = {
    'g6': {side:'w', type:'king'},
    'h6': {side:'w', type:'queen'},
    'g8': {side:'b', type:'king'},
    'g7': {side:'b', type:'pawn'},
  };
  state = { selecting:false, selected:null };
  boardEl.style.display = '';
  boardEl.style.opacity = 1;
  document.getElementById('msg').style.display = '';
  document.getElementById('msg').style.opacity = 1;
  sceneRoot.classList.remove('visible');
  sceneRoot.style.pointerEvents = 'none';
  sceneRoot.setAttribute('aria-hidden','true');
  sceneRoot.querySelectorAll('*').forEach(el => {
    // remove inline style used by previous animation
    el.style.transition = '';
    el.style.animation = '';
    el.style.transform = '';
    el.style.opacity = '';
  });
  buildBoard();
});

/* ---------- SCENE TIMELINE ----------
   The scene animation is controlled with a precise timeline of promises.
   We'll orchestrate:
   1) draw queen outline (stroke-dash animation already in CSS via classes)
   2) reveal head/face/hair/cloak in sequence
   3) show speedlines
   4) reveal sword (blade fills) and trail
   5) sword swoop (big transform)
   6) impact: flare, crown fly, king fall, subtle camera shake
   7) hold final frame
---------------------------------------*/

function startScene(){
  sceneRoot.classList.add('visible');
  sceneRoot.style.pointerEvents = 'auto';
  sceneRoot.setAttribute('aria-hidden','false');

  // query SVG elements
  const svg = sceneSvg;
  const qBody = svg.getElementById('qBody');
  const qHead = svg.getElementById('qHead');
  const qHair = svg.getElementById('qHair');
  const qFace = svg.getElementById('qFace');
  const qCloak1 = svg.getElementById('qCloak1');
  const qCloak2 = svg.getElementById('qCloak2');
  const qSwordGroup = svg.getElementById('qSword');
  const sBlade = svg.getElementById('sBlade');
  const sHandle = svg.getElementById('sHandle');
  const sTrail = svg.getElementById('sTrail');

  const speed = svg.getElementById('speedlines');
  const camera = svg.getElementById('camera');
  const impactGroup = svg.getElementById('impactGroup');
  const impactCircle = svg.getElementById('impactCircle');
  const crownFly = svg.getElementById('crownFly');
  const king = svg.getElementById('kingGroup');
  const crownOriginal = svg.getElementById('kCrown');

  // ensure initial state
  [sBlade, sHandle].forEach(el => { el.style.opacity = 0; el.style.transform = 'translate(0,0)'; });
  sTrail.style.opacity = '0';
  qBody.style.opacity = 1;
  qHead.style.opacity = 1;
  qHair.style.opacity = 1;
  qFace.style.opacity = 1;
  qCloak1.style.opacity = 1;
  qCloak2.style.opacity = 1;
  speed.classList.remove('show');
  impactGroup.style.opacity = 0;
  crownFly.style.opacity = 0;

  // helper: return promise after timeout
  const wait = ms => new Promise(res => setTimeout(res, ms));

  // sequence
  (async function timeline(){
    // 1) Draw queen lines in staged manner
    // CSS classes on paths already animate drawLine/drawLineFast (declared in CSS).
    // But to orchestrate, we'll trigger by reflow (re-adding classes)
    const drawEls = [qBody, qHead, qHair, qFace, qCloak1, qCloak2];
    drawEls.forEach(el => {
      el.style.stroke = 'white';
      el.style.fill = 'none';
      // force reflow removal and add to restart
      el.classList.remove('line-draw', 'line-draw-fast');
      void el.getBBox;
      if(el.id === 'qBody') { el.classList.add('line-draw'); el.style.strokeWidth = 3.2; }
      else { el.classList.add('line-draw-fast'); el.style.strokeWidth = 2.2; }
    });
    await wait(800);

    // 2) Slight idle then start speedlines
    await wait(220);
    speed.classList.add('show');

    // 3) reveal sword blade and handle (fade-in)
    sBlade.style.transition = 'opacity 220ms ease';
    sHandle.style.transition = 'opacity 220ms ease';
    sBlade.style.opacity = 1;
    sHandle.style.opacity = 1;
    // reveal subtle trail
    sTrail.style.transition = 'stroke-opacity 240ms ease';
    sTrail.style.strokeOpacity = 0.28;
    await wait(180);

    // 4) Build anticipation: hero lean forward (small transform)
    camera.animate([
      { transform: 'translate(0px,0px) scale(1)' },
      { transform: 'translate(-8px,0px) scale(1.01)' }
    ], { duration: 260, easing: 'cubic-bezier(.2,.9,.2,1)', fill: 'forwards' });

    await wait(260);

    // 5) Sword big swoop: animate qSword group transform across timeline
    // We'll animate using Web Animations API for precise control.
    const swordAnim = qSwordGroup.animate([
      { transform: 'translate(62px,-26px) rotate(-36deg)' },
      { transform: 'translate(200px,-72px) rotate(18deg)' },
      { transform: 'translate(420px,-100px) rotate(36deg)' }
    ], { duration: 420, easing: 'cubic-bezier(.08,.95,.2,1)', fill: 'forwards' });

    // trail flash intensifies during stroke
    sTrail.animate([
      { strokeOpacity: 0.18 },
      { strokeOpacity: 0.92 },
      { strokeOpacity: 0.04 }
    ], { duration: 420, easing: 'ease-out', fill:'forwards' });

    // small sword blade pulse (to imitate flash)
    sBlade.animate([
      { opacity: 1, transform: 'scaleX(1)' },
      { opacity: 1, transform: 'scaleX(1.06)' },
      { opacity: 0.9, transform: 'scaleX(1)' }
    ], { duration: 420, easing: 'cubic-bezier(.2,.9,.2,1)', fill:'forwards' });

    await swordAnim.finished;

    // 6) Impact: show impact circle pop and camera shake
    impactGroup.style.opacity = 1;
    impactCircle.animate([
      { r: 0, opacity: 0.9 },
      { r: 160, opacity: 0.96 },
      { r: 220, opacity: 0 }
    ], { duration: 520, easing: 'cubic-bezier(.2,.9,.2,1)', fill: 'forwards' });

    // camera heavy shake sequence
    camera.animate([
      { transform: 'translate(0px,0px) scale(1)' },
      { transform: 'translate(-6px,-4px) scale(1.03) rotate(-0.6deg)' },
      { transform: 'translate(8px,6px) scale(1.02) rotate(0.6deg)' },
      { transform: 'translate(-4px,-2px) scale(1.01)' },
      { transform: 'translate(0px,0px) scale(1)' }
    ], { duration: 900, easing: 'cubic-bezier(.2,.9,.2,1)', fill:'forwards' });

    // 7) Crown fly: animate separate element flying from king area
    crownFly.style.opacity = 1;
    const crownAnim = crownFly.animate([
      { transform: 'translate(0px,0px) rotate(0deg)', opacity: 1 },
      { transform: 'translate(120px,-120px) rotate(28deg)', opacity: 0 }
    ], { duration: 940, easing: 'cubic-bezier(.2,.9,.2,1)', fill:'forwards' });

    // 8) King fall: animate kingGroup transform (translate + rotate)
    king.animate([
      { transform: 'translate(880px,320px) rotate(0deg)', opacity: 1 },
      { transform: 'translate(920px,460px) rotate(72deg)', opacity: 0.96 }
    ], { duration: 920, easing: 'cubic-bezier(.2,.9,.2,1)', fill:'forwards' });

    // fade speedlines
    speed.classList.remove('show');
    // fade some foreground
    const flash = svg.getElementById('flash');
    if(flash) {
      flash.style.transition = 'opacity 260ms ease';
      flash.style.opacity = 1;
      setTimeout(()=> { flash.style.opacity = 0; }, 400);
    }

    await wait(420);

    // 9) settle: slight slow motion pose hold
    camera.animate([
      { transform: 'translate(0px,0px) scale(1)' },
      { transform: 'translate(-2px,-1px) scale(1.01)' },
      { transform: 'translate(0px,0px) scale(1)' }
    ], { duration: 1200, fill:'forwards', easing:'ease-out' });

    // 10) End state: keep scene visible; user may reset to return
  })();

}

/* ---------- Initialize ---------- */
buildBoard();
</script>
</body>
</html>
