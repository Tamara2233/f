<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Сердце из фейерверков</title>
  <style>
    html,body { height:100%; margin:0; }
    body {
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      overflow: hidden;
      color: #fff;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .center {
      position: absolute;
      left:50%;
      top:50%;
      transform: translate(-50%,-50%);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index: 5;
    }
    button#start {
      background: #fff;
      color: #000;
      border: none;
      padding: 18px 34px;
      font-size: 20px;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(255,255,255,0.06), 0 2px 6px rgba(0,0,0,0.4);
      transition: transform .15s ease, opacity .3s ease;
      user-select: none;
    }
    button#start:active { transform: translateY(1px) scale(.995); }
    button#start.hidden { opacity: 0; transform: scale(.9) translateY(-8px); pointer-events: none; }
    canvas#fx { position: absolute; left:0; top:0; width:100%; height:100%; display:block; z-index:1; }
    .hint { position: absolute; left:50%; top:calc(50% + 70px); transform: translateX(-50%); color: rgba(255,255,255,0.6); font-size: 13px; z-index:4; transition: opacity .3s ease; text-align:center; max-width:90%; }
    .hint.hidden { opacity:0; pointer-events:none; }
    @media (max-width:460px) { button#start { padding: 14px 26px; font-size:18px; } .hint { top: calc(50% + 60px); font-size:12px; } }
  </style>
</head>
<body>
  <div class="center">
    <button id="start" aria-label="Нажми меня">Нажми меня</button>
  </div>
  <div class="hint" id="hint">Кликни по кнопке — смотри, как собирается сердце из фейерверков ✨</div>
  <canvas id="fx"></canvas>
  <script>
    const canvas = document.getElementById('fx');
    const ctx = canvas.getContext('2d', { alpha: true });
    const startBtn = document.getElementById('start');
    const hint = document.getElementById('hint');

    function resize() {
      canvas.width = innerWidth * devicePixelRatio;
      canvas.height = innerHeight * devicePixelRatio;
      canvas.style.width = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    addEventListener('resize', resize);
    resize();

    function lerp(a, b, t) { return a + (b - a) * t; }

    function heartPoint(t, scale=1) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
      return { x: x * scale, y: y * scale };
    }

    function generateHeartPoints(count, centerX, centerY, scale) {
      const pts = [];
      for (let i = 0; i < count; i++) {
        const t = (i / count) * Math.PI * 2;
        const p = heartPoint(t, scale);
        pts.push({ x: centerX + p.x, y: centerY + p.y });
      }
      return pts;
    }

    class Particle {
      constructor(x, y, tx, ty, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random()-0.5) * 6;
        this.vy = (Math.random()-0.6) * 6;
        this.tx = tx; this.ty = ty;
        this.life = 1;
        this.size = Math.random() * 2.2 + 1;
        this.color = color;
        this.delay = Math.random() * 0.6;
        this.age = 0;
      }
      update(dt) {
        if (this.delay > 0) { this.delay -= dt; return; }
        this.age += dt;
        this.vx += (this.tx - this.x) * 0.004;
        this.vy += (this.ty - this.y) * 0.004;
        this.vx *= 0.96;
        this.vy *= 0.96;
        this.x += this.vx * (dt*60);
        this.y += this.vy * (dt*60);
        const d2 = (this.x - this.tx)*(this.x - this.tx) + (this.y - this.ty)*(this.y - this.ty);
        if (d2 < 16) {
          this.life -= dt * 0.8;
          this.size = Math.max(0.2, this.size * 0.98);
        }
      }
      draw(ctx) {
        if (this.delay > 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      isDead() { return this.life <= 0; }
    }

    class Spark {
      constructor(x,y, vx, vy, color) {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.life = Math.random()*0.8 + 0.4;
        this.size = Math.random()*1.6 + 0.6;
        this.color = color;
      }
      update(dt) {
        this.vy += 60 * dt;
        this.x += this.vx * (dt*60);
        this.y += this.vy * (dt*60);
        this.life -= dt;
      }
      draw(ctx) {
        const alpha = Math.max(0, this.life / 1.2);
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = this.color;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      isDead() { return this.life <= 0; }
    }

    const particles = [];
    const sparks = [];
    let lastTime = performance.now();
    let running = false;
    let heartPoints = [];
    const palette = ['#FF4D6D','#FF7A9B','#FFD166','#FF6B6B','#FF9A6B','#FFD1DC','#FF5E9E'];

    // --- Текстовые частицы ---
    let textParticles = [];
    let textAssembleTimer = 0;
    const textAssembleDelay = 2.0;

    function createTextParticles(text, fontSize) {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      tempCtx.font = `${fontSize}px sans-serif`;
      tempCtx.fillStyle = 'white';
      tempCtx.textAlign = 'center';
      tempCtx.textBaseline = 'middle';
      tempCtx.fillText(text, canvas.width/2, canvas.height/2);
      const imageData = tempCtx.getImageData(0,0,tempCanvas.width,tempCanvas.height).data;
      const particlesArr = [];
      for(let y=0; y<tempCanvas.height; y+=6){
        for(let x=0; x<tempCanvas.width; x+=6){
          const alpha = imageData[(y*tempCanvas.width + x)*4+3];
          if(alpha > 128){
            let startX, startY;
            const corner = Math.floor(Math.random()*4);
            if(corner===0){ startX=0; startY=0; }
            if(corner===1){ startX=canvas.width; startY=0; }
            if(corner===2){ startX=0; startY=canvas.height; }
            if(corner===3){ startX=canvas.width; startY=canvas.height; }
            particlesArr.push({x:startX,y:startY,tx:x,ty:y,vx:(Math.random()-0.5)*2,vy:(Math.random()-0.5)*2,size:2,life:1,phase:'chaotic'});
          }
        }
      }
      return particlesArr;
    }

    function updateTextParticles(dt){
      textAssembleTimer += dt;
      for(let i=0;i<textParticles.length;i++){
        const p = textParticles[i];
        if(p.phase==='chaotic'){
          p.x += p.vx;
          p.y += p.vy;
          p.vx += (Math.random()-0.5)*0.2;
          p.vy += (Math.random()-0.5)*0.2;
          if(textAssembleTimer >= textAssembleDelay) p.phase='assembling';
        } else if(p.phase==='assembling'){
          p.vx += (p.tx - p.x)*0.05;
          p.vy += (p.ty - p.y)*0.05;
          p.vx *= 0.8;
          p.vy *= 0.8;
          p.x += p.vx;
          p.y += p.vy;
        }
      }
    }

    function drawTextParticles(ctx){
      ctx.save();
      ctx.fillStyle='white';
      ctx.globalCompositeOperation='lighter';
      for(let i=0;i<textParticles.length;i++){
        const p = textParticles[i];
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function startAnimation() {
      if (running) return;
      running = true;
      startBtn.classList.add('hidden');
      hint.classList.add('hidden');

      const centerX = innerWidth / 2;
      const centerY = innerHeight / 2 - Math.min(80, innerHeight*0.05);
      const scale = Math.min(innerWidth, innerHeight) / 36;
      const total = Math.floor(1200 * Math.min(1, Math.min(innerWidth,innerHeight)/800));
      heartPoints = generateHeartPoints(total, centerX, centerY, scale);

      for (let i=0;i<heartPoints.length;i++){
        const hp = heartPoints[i];
        const sx = Math.random()*innerWidth;
        const sy = innerHeight + Math.random()*200 + 20;
        const color = palette[Math.floor(Math.random()*palette.length)];
        particles.push(new Particle(sx, sy, hp.x, hp.y, color));
      }

      lastTime = performance.now();
      requestAnimationFrame(loop);
      sparkleInterval = setInterval(spawnFireworkBurst, 600);
      spawnFireworkBurst(centerX, centerY - scale*10, 40);
      spawnFireworkBurst(centerX - scale*4, centerY - scale*20, 32);
    }

    function spawnFireworkBurst(x = Math.random()*innerWidth, y = Math.random()*innerHeight*0.6 + innerHeight*0.1, count=30) {
      const baseColor = palette[Math.floor(Math.random()*palette.length)];
      for (let i=0;i<count;i++){
        const ang = Math.random()*Math.PI*2;
        const speed = Math.random()*3 + 1.2;
        const vx = Math.cos(ang) * speed * (Math.random()*0.9 + 0.5) * 6;
        const vy = Math.sin(ang) * speed * (Math.random()*0.9 + 0.5) * 6;
        sparks.push(new Spark(x, y, vx, vy, baseColor));
      }
    }

    let sparkleInterval = null;

    function loop(now) {
      const dt = Math.min(0.035, (now - lastTime) / 1000);
      lastTime = now;

      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(0,0,innerWidth,innerHeight);

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update(dt);
        p.draw(ctx);
        if (Math.random() < 0.04 && p.delay <= 0) {
          sparks.push(new Spark(p.x, p.y, (Math.random()-0.5)*6, (Math.random()-0.9)*6, p.color));
        }
        if (p.isDead()){
          for (let k=0;k<6;k++){
            sparks.push(new Spark(p.x, p.y, (Math.random()-0.5)*8, (Math.random()-0.8)*8, p.color));
          }
          particles.splice(i,1);
        }
      }

      for (let i = sparks.length - 1; i >= 0; i--) {
        const s = sparks[i];
        s.update(dt);
        s.draw(ctx);
        if (s.isDead()) sparks.splice(i,1);
      }

      // запуск текста, когда сердце сформировано
      if(particles.length===0 && textParticles.length===0){
        textParticles = createTextParticles('Ты пидор', Math.floor(Math.min(innerWidth,innerHeight)/8));
        textAssembleTimer = 0;
      }

      if(textParticles.length>0){
        updateTextParticles(dt);
        drawTextParticles(ctx);
      }

      if (running && (particles.length > 0 || sparks.length > 0 || textParticles.length>0)) {
        requestAnimationFrame(loop);
      } else if(sparkleInterval){
        clearInterval(sparkleInterval);
        sparkleInterval = null;
      }
    }

    startBtn.addEventListener('click', startAnimation);
    canvas.addEventListener('click', () => { if(!running) startAnimation(); });
  </script>
</body>
</html>
