<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Мат королевой — аниме сцена</title>
<style>
  :root{
    --bg1:#071026; --bg2:#041623;
    --sq-light:#f3ecd7; --sq-dark:#6b4b33;
    --accent:#ffb86b;
    --card:#071726aa;
    --board-max:640px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px;
    font-family: Inter, "Helvetica Neue", Arial, sans-serif;
    background: radial-gradient(1200px 600px at 10% 10%, rgba(20,40,60,0.35), transparent),
                linear-gradient(180deg,var(--bg1) 0%, var(--bg2) 100%);
    color:#e7f0fb;
  }
  .container{
    width:100%;
    max-width:1120px;
    margin:auto;
    display:grid;
    grid-template-columns: 1fr 560px;
    gap:28px;
    align-items:start;
  }
  @media (max-width:980px){
    .container{ grid-template-columns: 1fr; padding-bottom:40px }
  }

  /* left: board + controls */
  .panel{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border-radius:14px;
    padding:18px;
    box-shadow: 0 18px 50px rgba(2,6,20,0.6);
  }
  h1{ margin:0 0 6px 0; font-size:18px }
  p.small{ margin:0 0 14px 0; color:#b8d3ea }

  .board-wrap{
    width:100%;
    max-width:var(--board-max);
    margin:auto;
    border-radius:12px;
    padding:12px;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.04));
  }

  /* responsive square grid using aspect-ratio */
  .board{
    display:grid;
    grid-template-columns: repeat(8,1fr);
    gap:0;
    border-radius:8px;
    overflow:hidden;
    width:100%;
    user-select:none;
  }
  .cell{
    position:relative;
    aspect-ratio: 1 / 1;
    display:flex;
    align-items:center;
    justify-content:center;
    transition:background 160ms ease, transform 120ms ease;
    cursor:pointer;
  }
  .cell.light{ background: var(--sq-light); }
  .cell.dark{ background: var(--sq-dark); color:#fff; }
  .cell.highlight{ box-shadow: inset 0 0 0 6px rgba(255,184,103,0.22); }
  .cell.invalid{ animation: pulse 420ms ease; }
  @keyframes pulse { 0%{ transform:translateX(0)} 50%{ transform:translateX(-6px)} 100%{ transform:translateX(0)} }

  .piece {
    width:70%;
    height:70%;
    display:block;
    pointer-events:none;
    filter: drop-shadow(0 10px 18px rgba(3,8,20,0.5));
    transition: transform 200ms ease;
  }
  .controls{
    display:flex; gap:8px; align-items:center; margin-top:10px;
  }
  .btn{
    background:linear-gradient(180deg,#2f7dff,#1d4ed8);
    color:white; border:none; padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600;
  }
  .hint{ color:#9cc5e5; font-size:14px; }

  /* right: scene */
  .scene-card{
    border-radius:14px;
    padding:12px;
    background: linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.18));
    box-shadow: 0 20px 60px rgba(1,6,12,0.6);
    position:relative;
    overflow:hidden;
  }
  .scene {
    width:100%;
    height:420px;
    border-radius:10px;
    overflow:hidden;
    background: radial-gradient(800px 300px at 20% 10%, rgba(255,200,120,0.04), transparent),
               linear-gradient(180deg,#041024 0%, #02040a 100%);
    position:relative;
  }
  .scene svg{ width:100%; height:100%; display:block; }

  .caption{
    margin-top:10px; color:#cfe7ff; font-size:13px; text-align:center;
  }

  /* animation helper classes */
  .fade-out{ animation: fadeOut 420ms forwards; }
  @keyframes fadeOut{ to { opacity:0; transform:scale(0.98); } }

  .center-note{ text-align:center; color:#c2dff6; font-size:13px; margin-top:10px; }

</style>
</head>
<body>
  <div class="container">
    <div class="panel">
      <h1>Шахматная задача — мат королевой в 1 ход</h1>
      <p class="small">Нажми на белую ♕ (королеву), затем на подсвеченную клетку — правильный ход запускает аниме-сцену.</p>

      <div class="board-wrap" id="boardWrap">
        <div id="board" class="board" aria-label="Шахматная доска"></div>

        <div class="controls">
          <button id="reset" class="btn">Сбросить позицию</button>
          <div style="flex:1" class="hint">Позиция: Белые: Kg6, Qh6. Чёрные: Kg8, pg7. Ход белых.</div>
        </div>
      </div>

      <div class="center-note" id="message">Выбери ферзя ♕, затем цель для мата.</div>
    </div>

    <div class="scene-card">
      <h1 style="margin:0 0 8px 0;font-size:18px">Аниме-стилизованная сцена — динамика Attack on Titan</h1>
      <div class="scene" id="scene" aria-hidden="true">
        <!-- SVG сцена вставится сюда -->
      </div>
      <div class="caption">Сцена: превращение → рывок → корона летит → король падает. Никакой графики — только драматизм.</div>
    </div>
  </div>

<script>
/* ========== ИНФОРМАЦИЯ О ПОЗИЦИИ (легальная) ==========
   Белые: Kg6, Qh6
   Чёрные: Kg8, pg7
   Ход белых. Мат: Qxg7# — король не может взять ферзя,
   потому что g7 защищено белым королём на g6.
======================================================*/

const files = ['a','b','c','d','e','f','g','h'];
const ranks = [8,7,6,5,4,3,2,1];
const board = document.getElementById('board');
const message = document.getElementById('message');
const scene = document.getElementById('scene');
const resetBtn = document.getElementById('reset');

let state = { selected:null, moving:false };

let pieces = {
  'g6': {side:'w', type:'king'},
  'h6': {side:'w', type:'queen'},
  'g8': {side:'b', type:'king'},
  'g7': {side:'b', type:'pawn'}
};

const source = 'h6';
const target = 'g7';

function makeBoard(){
  board.innerHTML = '';
  for(let r=0;r<8;r++){
    for(let f=0;f<8;f++){
      const sq = files[f] + ranks[r];
      const div = document.createElement('div');
      div.className = 'cell ' + (((f + r) % 2 === 0) ? 'light' : 'dark');
      div.dataset.sq = sq;
      div.addEventListener('click', onCellClick);
      if(pieces[sq]){
        const wrapper = document.createElement('div');
        wrapper.innerHTML = getPieceSVG(pieces[sq].side, pieces[sq].type);
        wrapper.firstElementChild.classList.add('piece');
        // make source selectable
        if(sq === source && pieces[sq].type === 'queen'){
          wrapper.style.cursor = 'pointer';
          wrapper.title = 'Кликни, чтобы выбрать королеву';
          wrapper.firstElementChild.addEventListener('click', (e)=>{
            e.stopPropagation();
            selectSource(sq);
          });
        } else {
          wrapper.style.pointerEvents = 'none';
        }
        div.appendChild(wrapper);
      }
      board.appendChild(div);
    }
  }
  message.textContent = 'Выбери ферзя ♕, затем целевую клетку для мата.';
}

function selectSource(sq){
  if(state.moving) return;
  state.selected = sq;
  state.moving = true;
  document.querySelectorAll('.cell').forEach(c=>c.classList.remove('highlight'));
  document.querySelector(`[data-sq="${sq}"]`).classList.add('highlight');
  document.querySelector(`[data-sq="${target}"]`).classList.add('highlight');
  message.textContent = 'Королева выбрана. Кликни по подсвеченной клетке.';
}

function onCellClick(e){
  const sq = e.currentTarget.dataset.sq;
  if(!state.moving){
    // hint shake
    e.currentTarget.classList.add('invalid');
    setTimeout(()=>e.currentTarget.classList.remove('invalid'),380);
    message.textContent = 'Сначала выбери ферзя (♕).';
    return;
  }
  if(state.selected !== source){
    message.textContent = 'Неверный выбор фигуры.';
    return;
  }
  if(sq === target){
    // correct move
    message.textContent = 'Ход выполнен — мат. Запуск сцены...';
    animateMove(source, target, ()=> {
      // update logical board
      delete pieces[source];
      delete pieces[target]; // capture pawn
      pieces[target] = {side:'w', type:'queen'};
      // fresh board and start scene
      setTimeout(()=>{ makeBoard(); startScene(); }, 350);
    });
  } else {
    message.textContent = 'Это не тот ход. Нажми на подсвеченную клетку.';
    e.currentTarget.classList.add('invalid');
    setTimeout(()=>e.currentTarget.classList.remove('invalid'),380);
  }
}

// animate simple piece move visually (clone)
function animateMove(from,to,cb){
  const fromEl = document.querySelector(`[data-sq="${from}"]`);
  const toEl = document.querySelector(`[data-sq="${to}"]`);
  const pieceEl = fromEl.querySelector('.piece');
  if(!pieceEl){ if(cb) cb(); return; }
  const clone = pieceEl.cloneNode(true);
  clone.style.position='absolute';
  const boardRect = board.getBoundingClientRect();
  const fRect = fromEl.getBoundingClientRect();
  clone.style.left = (fRect.left - boardRect.left) + 'px';
  clone.style.top  = (fRect.top - boardRect.top) + 'px';
  clone.style.width = fRect.width + 'px';
  clone.style.height = fRect.height + 'px';
  clone.style.zIndex = 999;
  clone.style.transition = 'all 420ms cubic-bezier(.2,.95,.2,1)';
  board.appendChild(clone);
  // remove original
  pieceEl.parentElement.remove();
  const tRect = toEl.getBoundingClientRect();
  requestAnimationFrame(()=> {
    clone.style.left = (tRect.left - boardRect.left) + 'px';
    clone.style.top  = (tRect.top - boardRect.top) + 'px';
    clone.style.transform = 'scale(1.02)';
  });
  setTimeout(()=>{ clone.remove(); if(cb) cb(); }, 460);
}

/* ======== SVG pieces (stylized, anime-like vectors) ======== */
function getPieceSVG(side, type){
  // side: 'w' or 'b'. We'll use color palettes.
  const palette = {
    w: {body:'#fff7f2', tone:'#ffd8a6', stroke:'#1b2130'},
    b: {body:'#2b3b4b', tone:'#1f2a36', stroke:'#071425'}
  };
  const p = palette[side];
  if(type === 'king'){
    return `
    <svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <g transform="translate(10,8)">
        <rect x="46" y="8" width="8" height="22" rx="2" fill="${p.tone}" stroke="${p.stroke}" stroke-width="1.2"/>
        <rect x="30" y="50" width="48" height="26" rx="6" fill="${p.body}" stroke="${p.stroke}" stroke-width="1.4"/>
        <path d="M14 50 C30 18, 78 18, 104 50 L104 74 L16 74 Z" fill="${p.body}" stroke="${p.stroke}" stroke-width="1.2"/>
        <circle cx="54" cy="28" r="12" fill="${p.tone}" stroke="${p.stroke}" stroke-width="1.2" />
        <!-- crown hint -->
        <g transform="translate(44,6)">
          <rect x="-10" y="-4" width="28" height="8" rx="2" fill="#ffd86b" stroke="#c77b00" stroke-width="0.9"/>
        </g>
      </g>
    </svg>`;
  }
  if(type === 'queen'){
    return `
    <svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <defs>
        <linearGradient id="qGrad" x1="0" x2="1"><stop offset="0" stop-color="#fffaf6"/><stop offset="1" stop-color="#ffdcb3" /></linearGradient>
      </defs>
      <g transform="translate(10,6)">
        <!-- body -->
        <path d="M16 58 C36 22, 84 22, 104 58 L92 86 L28 86 Z" fill="url(#qGrad)" stroke="#141821" stroke-width="1.2"/>
        <!-- cloak accent -->
        <path d="M28 86 C46 62, 76 62, 92 86" fill="#ffd7a8" opacity="0.25"/>
        <!-- head -->
        <circle cx="56" cy="30" r="12" fill="#fff8f2" stroke="#141821" stroke-width="1"/>
        <!-- ornate crown -->
        <g transform="translate(36,4)">
          <path d="M0,20 L8,0 L20,12 L32,0 L40,20 Z" fill="#ffd86b" stroke="#c77b00" stroke-width="0.9" transform="translate(-4,-6)"/>
        </g>
        <!-- sword hint (small) -->
        <rect x="74" y="36" width="36" height="6" rx="3" fill="#dfeffb" stroke="#9fbfe0" stroke-width="0.6" transform="rotate(18,74,36)"/>
      </g>
    </svg>`;
  }
  if(type === 'pawn'){
    return `
    <svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <g transform="translate(18,16)">
        <circle cx="36" cy="20" r="8" fill="${p.body}" stroke="${p.stroke}" stroke-width="1"/>
        <rect x="16" y="36" width="40" height="18" rx="4" fill="${p.body}" stroke="${p.stroke}" stroke-width="1.1"/>
      </g>
    </svg>`;
  }
  return '';
}

/* ===== Animation scene (anime-like, Attack-on-Titan inspired, non-graphic) ===== */
function startScene(){
  // hide board panel (soft)
  const boardWrap = document.getElementById('boardWrap');
  boardWrap.classList.add('fade-out');
  setTimeout(()=> boardWrap.style.display='none',420);

  // prepare scene SVG
  scene.innerHTML = `
  <svg viewBox="0 0 1280 720" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
    <defs>
      <linearGradient id="bg" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0" stop-color="#061423"/>
        <stop offset="1" stop-color="#02040a"/>
      </linearGradient>
      <filter id="glow" x="-40%" y="-40%" width="180%" height="180%">
        <feGaussianBlur stdDeviation="8" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>

    <rect width="100%" height="100%" fill="url(#bg)"/>

    <!-- speedlines background -->
    <g id="speedlines" opacity="0.0" transform="translate(0,0)">
      <rect x="0" y="0" width="1280" height="720" fill="none"/>
      <g stroke="#ffffff" stroke-opacity="0.06" stroke-width="6">
        <path d="M60 0 L420 720" stroke-linecap="round" />
        <path d="M140 0 L500 720" stroke-linecap="round" stroke-width="8" />
        <path d="M220 0 L580 720" stroke-linecap="round" />
      </g>
    </g>

    <!-- Hero (queen -> girl) on left -->
    <g id="hero" transform="translate(300,360)">
      <!-- shadow / silhouette -->
      <g id="heroBody">
        <path d="M-40 40 C-18 -40, 18 -40, 40 40 L40 90 L-40 90 Z" fill="#fff" opacity="0.95" transform="translate(0,-50)"/>
        <circle id="head" cx="0" cy="-60" r="16" fill="#fff"/>
      </g>
      <!-- long sword -->
      <g id="sword" transform="translate(54,-18) rotate(-36)">
        <rect x="-6" y="-6" width="180" height="12" rx="6" fill="#e9f3ff" stroke="#9fbfe0" stroke-width="1"/>
        <rect x="178" y="-2" width="46" height="8" rx="4" fill="#ffd86b"/>
      </g>
      <!-- anime face detail (appears during morph) -->
      <g id="face" opacity="0">
        <ellipse cx="0" cy="-60" rx="10" ry="12" fill="#fff8f2" />
        <path d="M-6 -58 Q0 -52 6 -58" stroke="#0d1b27" stroke-width="0.9" fill="none"/>
      </g>
      <!-- cloak / anime lines -->
      <g id="cloak" opacity="0.0">
        <path d="M-34 34 C-10 -6, 10 -6, 34 34 L20 84 L-20 84 Z" fill="#ffdcb1" opacity="0.85"/>
      </g>
    </g>

    <!-- Enemy king on right -->
    <g id="king" transform="translate(880,320)">
      <g id="kingBody">
        <rect x="-28" y="-76" width="56" height="112" rx="10" fill="#dbeefb" opacity="0.98"/>
        <circle cx="0" cy="-98" r="16" fill="#cfe8ff"/>
        <g id="crown" transform="translate(-0,-126)">
          <rect x="-22" y="0" width="44" height="10" rx="3" fill="#ffd86b"/>
          <polygon points="-22,0 -10,-12 0,0 10,-12 22,0" fill="#ffbf45"/>
        </g>
      </g>
    </g>

    <!-- impact flare -->
    <g id="impactGroup" opacity="0">
      <circle id="flare" cx="730" cy="300" r="0" fill="#fff7e6" opacity="0.8" />
    </g>

    <!-- final text -->
    <g id="final" opacity="0">
      <text x="640" y="120" text-anchor="middle" font-family="Inter, Roboto, sans-serif" font-weight="800" font-size="48" fill="#fff">Мат</text>
      <text x="640" y="160" text-anchor="middle" font-family="Inter, Roboto" font-size="18" fill="#cfe8ff">Королева решила партию</text>
    </g>
  </svg>
  `;

  // timeline parameters (ms)
  const t0 = 350;   // idle
  const t1 = 700;   // morph begin
  const t2 = 1200;  // charge/speedlines appear
  const t3 = 1500;  // swing/motion (impact)
  const t4 = 2200;  // crown fly, king fall
  const t5 = 3000;  // final

  const svg = scene.querySelector('svg');
  const speedlines = svg.getElementById('speedlines');
  const hero = svg.getElementById('hero');
  const sword = svg.getElementById('sword');
  const face = svg.getElementById('face');
  const cloak = svg.getElementById('cloak');
  const king = svg.getElementById('king');
  const crown = svg.getElementById('crown');
  const flare = svg.getElementById('flare');
  const impactGroup = svg.getElementById('impactGroup');
  const final = svg.getElementById('final');

  // idle gentle bob for hero
  hero.animate([
    { transform: 'translate(300px,360px) translateY(0px)' },
    { transform: 'translate(300px,360px) translateY(-6px)' },
    { transform: 'translate(300px,360px) translateY(0px)' }
  ], { duration: 800, iterations: Infinity, easing: 'ease-in-out' });

  // 1) morph: show face & cloak
  setTimeout(()=> {
    face.style.transition = 'opacity 260ms ease';
    face.style.opacity = '1';
    cloak.style.transition = 'opacity 260ms ease';
    cloak.style.opacity = '1';
  }, t1);

  // 2) speedlines and lean forward
  setTimeout(()=> {
    speedlines.style.transition = 'opacity 180ms linear';
    speedlines.style.opacity = '1.0';
    // hero lean forward (translate slightly)
    hero.animate([
      { transform: 'translate(300px,360px) translateX(0px)'},
      { transform: 'translate(300px,360px) translateX(18px) translateY(-10px) scale(1.02)'}
    ], { duration: 380, fill:'forwards', easing:'cubic-bezier(.15,.9,.25,1)' });
  }, t2);

  // 3) sword swing: big movement across screen (weapon passes near camera)
  setTimeout(()=> {
    sword.animate([
      { transform: 'translate(54px,-18px) rotate(-36deg)' },
      { transform: 'translate(220px,-70px) rotate(18deg)' },
      { transform: 'translate(420px,-100px) rotate(36deg)' }
    ], { duration: 420, easing:'cubic-bezier(.15,.9,.25,1)', fill:'forwards' });

    // flash flare at impact point
    impactGroup.style.transition='opacity 80ms linear';
    impactGroup.style.opacity='1';
    flare.animate([{ r:0, opacity:0.9 }, { r:160, opacity:0.95 }], { duration: 360, easing:'cubic-bezier(.2,.9,.2,1)', fill:'forwards' });

    // camera shake: scale svg slightly
    svg.animate([{ transform:'scale(1)'},{ transform:'scale(1.04)' },{ transform:'scale(1)' }], { duration: 700, fill:'forwards', easing:'ease-out' });

  }, t3);

  // 4) crown flies, king falls
  setTimeout(()=> {
    // move crown away from king
    crown.animate([
      { transform: 'translate(0,0) rotate(0deg)', opacity:1 },
      { transform: 'translate(110,-110) rotate(30deg)', opacity:0.0 }
    ], { duration: 900, fill:'forwards', easing:'cubic-bezier(.2,.9,.2,1)' });

    // king falls downwards and rotates
    king.animate([
      { transform: 'translate(880px,320px) rotate(0deg)', opacity:1 },
      { transform: 'translate(920px,460px) rotate(68deg)', opacity:0.95 }
    ], { duration: 900, fill:'forwards', easing:'cubic-bezier(.2,.9,.2,1)' });

    // fade out speedlines
    speedlines.style.transition='opacity 400ms linear';
    speedlines.style.opacity='0';
    impactGroup.style.transition='opacity 400ms linear';
    impactGroup.style.opacity='0';

  }, t4);

  // 5) final text
  setTimeout(()=> {
    final.style.transition='opacity 420ms ease';
    final.style.opacity='1';
  }, t5);

  // show "replay" control by clicking final area (or reset)
  // make scene visible (in case hidden)
  scene.style.opacity = 1;
}

// reset behavior
resetBtn.addEventListener('click', ()=>{
  // restore logical board
  pieces = {
    'g6': {side:'w', type:'king'},
    'h6': {side:'w', type:'queen'},
    'g8': {side:'b', type:'king'},
    'g7': {side:'b', type:'pawn'}
  };
  // show board
  const boardWrap = document.getElementById('boardWrap');
  boardWrap.style.display = '';
  boardWrap.classList.remove('fade-out');
  // clear scene
  scene.innerHTML = '';
  makeBoard();
  message.textContent = 'Позиция сброшена. Выбери ферзя ♕.';
  state.selected = null; state.moving = false;
});

// init
makeBoard();

</script>
</body>
</html>
